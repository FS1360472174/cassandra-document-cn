Cassandra提供ByteOrderedPartitioner为的是有序分区。为了后续兼容性被包含进来了。通过键的字节来对行词汇进行排序。可以看partition key数据的实际值来计算token，采用16进制表示key的首字母。例如，如果你想让行按字母顺序排列，你可以指定一个tokenA使用16进制的41表示。

使用有序分区器允许通过主键有序扫描。这意味着你可以扫描行就好像在索引中移动游标。例如，如果你的程序使用user names作为行键值，你可以扫描用户(姓名在Jake和Joe之间）。这对于Random分区器，这种方式的查询是做不到的，因为键值按照MD5的顺序存储，而不是顺序的。

尽管对于有序分区器来说扫描行这种能力听起来是一个分棒的特性，但通过table indexes也能实现同样的功能。

因为以下原因，不建议使用有序分区器:

**负载平衡难**

 　　需要更多的管理开销去实现集群的负载平衡。一个顺序的分区器需要管理员根据行键值的可能的分布情况去手动计算 [partition ranges](http://docs.datastax.com/en/glossary/doc/glossary/gloss_partition_range.html)。在实践中，一旦数据已经加载后，需要经常性的改变节点的token去适应实际数据的分布。

**顺序写导致热点**

 　　如果你的程序在某一段时间内的写入或者更新包含很多按顺序排列的行的时候，它们不会均匀的分布在集群上，会分布同一节点上。当系统处理和时间相关的数据的时候这是一个常见的问题。

**多表时负载不平衡**

 　　如果你的应用程序用到多个表，这些表有不同的行键值和不同的数据分布。在同一个集群中，对于一张表一个有序的分区对于另一个表可能会导致热点和不均匀分布。